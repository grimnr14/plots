den[is.na(den)]<-0
}
}
}
}
if(length(den)==1){#THIS LINE WAS EDITED TO CORRECT MISMATCH EVALUATION 2-4-25
ex[,i]<-num
}else{
ex[,i]<-ifelse(den==0,0,num/den)#edited to correct div by 0 error
}
}
#clean
ex<-ex[,c("GEOID",vars$variable)]
ex[ex=="Inf"]<-NA
#ex$lowaccesspopsharehalf<-ex$lowaccesspopsharehalf*100
ex$lowaccesspopshare1<-100*ex$lowaccesspopshare1
ex$lowaccesspopshare10<-100*ex$lowaccesspopshare10
#ex$lowaccesschildrensharehalf<-100*ex$lowaccesschildrensharehalf
ex$lowaccesschildrenshare1<-100*ex$lowaccesschildrenshare1
ex$lowaccesschildrenshare10<-100*ex$lowaccesschildrenshare10
#ex$lowaccessseniorssharehalf<-100*ex$lowaccessseniorssharehalf
ex$lowaccessseniorsshare1<-100*ex$lowaccessseniorsshare1
ex$lowaccessseniorsshare10<-100*ex$lowaccessseniorsshare10
#ex$lowaccesssnapsharehalf<-100*ex$lowaccesssnapsharehalf
ex$lowaccesssnapshare1<-100*ex$lowaccesssnapshare1
ex$lowaccesssnapshare10<-100*ex$lowaccesssnapshare10
ex$groceryfoodstores<-ex$groceryfoodstores/1000
ex$supercentersandfoodclubstores<-ex$supercentersandfoodclubstores/1000
ex$conveniencestores<-ex$conveniencestores/1000
ex$snapauthorizedfoodstores<-ex$snapauthorizedfoodstores/1000
#ex$wicauthorizedfoodstores<-ex$wicauthorizedfoodstores/1000
ex$fastfoodrestaurants<-ex$fastfoodrestaurants/1000
ex$fullservicerestaurants<-ex$fullservicerestaurants/1000
#ex$foodbanksper1k<-ex$foodbanksper1k*1000
ex$receiptofssiorsnap<-100*ex$receiptofssiorsnap
ex$receiptofssiorsnapinfamilies<-100*ex$receiptofssiorsnapinfamilies
ex$receiptofsnap<-100*ex$receiptofsnap
ex$householdcashassistfoodorsnap<-100*ex$householdcashassistfoodorsnap
ex$householdsnaponly<-100*ex$householdsnaponly
ex$snapfamilyany<-100*ex$snapfamilyany
ex$snapfamilysnap5p<-100*ex$snapfamilysnap5p
ex$householdreceiptoffoodstamps<-100*ex$householdreceiptoffoodstamps
ex$householdw60psnap<-100*ex$householdw60psnap
ex$householdw18msnap<-100*ex$householdw18msnap
ex$householdmarriedsnap<-100*ex$householdmarriedsnap
ex$householdmalehomesnap<-100*ex$householdmalehomesnap
ex$householdfemalehomesnap<-100*ex$householdfemalehomesnap
ex$householdw1pdisabledsnap<-100*ex$householdw1pdisabledsnap
ex$novehiclesavailable<-100*ex$novehiclesavailable
ex$NAME<-as.character(1:nrow(ex))
ex<-ex[,c("GEOID","NAME",names(ex)[!names(ex) %in% c("GEOID","NAME","valid")&is.na(as.numeric(substr(names(ex),2,5)))&str_detect(names(ex),"half")==F])]
out<-makeIndex(x=ex[complete.cases(ex),],geoid="GEOID",nfactors=4,state=NULL)
#    out<-makeIndex(x=ex[complete.cases(ex),],geoid="GEOID",nfactors=4,state=NULL,
#                   set.factor=list(financial=c(),
#                                   ownership=c(),
#                                   building_quality=c(),
#                                   crowding=c()
#                   ))
food<-merge(ex[,c("GEOID",vars$variable)],
out$score[,c("GEOID","full_score","ranked_percentile")],
by="GEOID",all.x=T)
food<-merge(food,
out$sub_score[,c("GEOID","factor_1","factor_2","factor_3","factor_4")],
by="GEOID",all.x=T)
food<-score_state(x=food,geography=geography,geoid="GEOID",year=year)
food<-food[,!names(food) %in% c("STATEFP","state_ranked_decile")]
names(food)<-c("GEOID",vars$variable,"food_score","food_rnk",
"food_score1","food_score2","food_score3","food_score4",
#"geometry",#toggle off from zcta...
"food_state_rnk")
if(calc.adi==T){
food<-food[,!names(food) %in% c("vehicles")]
}
base<-merge(base,food,by="GEOID",all.x=T)
gc()
}
base<-merge(base,map[,!names(map) %in% c("geometry")],by="GEOID",all.x=T)
base[!duplicated(base),]
}
testing<-F
if(testing==T){
source("https://raw.githubusercontent.com/grimnr14/R-functions/refs/heads/main/flatMap.R")
ex<-pullACS(geography="county",variables=c("B01001_001","B01002_001"),state=state.abb,geometry=F,year=2023,calc.adi=F,survey="acs5",calc="transportation")
ex<-pullACS(geography="county",variables=c("B01001_001","B01002_001"),state=state.abb,geometry=F,year=2019,calc.adi=F,survey="acs5",calc="food")
ex<-pullACS(geography="county",variables=c("B01001_001","B01002_001"),state="MD",impute=T,impute.method="rpart",geometry=F,year=2023,calc.adi=F,survey="acs5",calc="transportation")
ex<-pullACS(geography="tract",variables=c("B01001_001","B01002_001"),state=state.abb,geometry=F,year=2022,calc.adi=F,survey="acs5",calc="transportation")
ex<-pullACS(geography="zcta",variables=c("B01001_001","B01002_001"),state=NULL,geometry=F,year=2020,calc.adi=F,survey="acs5",calc="housing")
flat_map(data=as.data.frame(ex),
year=2023,state="MD",geography="county",
geoid="GEOID",var="ranked_percentile")
exs<-NULL
for(j in c("county","zip code tabulation area","tract")){
saveRDS(pullACS(geography=j,state=state.abb,geometry=T,year=2019,calc="housing",calc.adi=F,survey="acs5"),
paste0("C:/Users/chris/OneDrive/Desktop/GeoHealth/data/housing_",j,"_2019_sf.rds"))
ex<-pullACS(geography=j,state=state.abb,year=2019,calc="housing",calc.adi=F,geometry=F,survey="acs5")
ex<-pullACS(geography=j,state=state.abb,year=2019,calc="housing",calc.adi=F,geometry=F,survey="acs5",impute=T)
nams<-names(ex)[!names(ex) %in% c("B01001_001","GEOID","housing_score","housing_rnk","financial_score","ownership_score","building_quality_score","other_housing_score")]
for(i in nams){
nam<-paste0("z_",i)
#ex[,nam]<- liver::transform(ex[,i], method = "zscore") #x is now normalized THIS STOPPED WORKING
ex[,nam]<-liver::zscore(ex[,i])
}
ex$NAME<-as.character(1:nrow(ex))
ex$geography<-j
exs<-rbind(exs,ex)
obj<-makeIndex(x=ex[,names(ex) %in% c("GEOID","NAME",nams)],geoid="GEOID",nfactors=4,state=NULL,
set.factor=list(financial=c("housingvalue","mortgage","mortgagecost","mortgagetax","mortgageval","rentgross"),
ownership=c("occupyown","unitsownpop","vehicle","rooms"),
building_quality=c("fuelheat","kitchen","plumbing"),
other=c("occupy","rentprcinc","units"))
)
saveRDS(obj,paste0("C:/Users/chris/OneDrive/Desktop/GeoHealth/data/housing_",j,"_2019_output.rds"))
}
saveRDS(exs[,c("GEOID","geography",nams,paste0("z_",nams),"housing_score","housing_rnk","financial_score","ownership_score","building_quality_score","other_housing_score")],
paste0("C:/Users/chris/OneDrive/Desktop/GeoHealth/data/housing_2019.rds"))
}
if(testing==T){
test1<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=F,calc="housing")
test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="rpart",calc="housing")
test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="rpart",calc="transportation")
test2<-pullACS(geography="county",state=state.abb,geometry=F,year=2019,impute=T,impute.method="rpart",calc="transportation")
#test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="lm",calc="housing")
#test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="mice",calc="housing")#mice broken inside of pullACS function
source("C:/Users/chris/OneDrive/Desktop/GeoHealth/scripts/jaccard.r")
jaccard(round(test1[,2:(ncol(test1)-1)],1),round(test2[rownames(test1),2:(ncol(test2)-1)],1))
summary(test1)
summary(test2)
summary(test1[,2:(ncol(test1)-1)]-test2[rownames(test1),2:(ncol(test2)-1)])
}
test2<-pullACS(geography="county",state=state.abb,geometry=F,year=2019,impute=T,impute.method="rpart",calc="food")
plot(density(test2$food_score))
plot(density(na.omit(test2$food_score)))
geography="county"
variables=c("B01001_001")
state=state.abb
year=2019
impute=F
impute.method="rpart"
calc="none"
calc.adi=F
survey="acs5"
calc<-"food"
geometry<-F
ex<-get_acs(geography=geography,variables=variables,state=state,year=year,geometry=geometry,survey=survey)
newvars<-unique(c(variables,"B01001_001","B25001_001","B26001_001","B19113_001"))
map<-as.data.frame(ex[,c("GEOID","NAME")])
ex<-ex[!is.na(ex$estimate),]
ex<-spread(data=ex[,c("GEOID","variable","estimate")],key=variable,value=estimate,fill=NA)
#ex[ex==-666666666]<-NA
#impute base block groups
if(geography=="block group"&impute==T){
for(i in newvars[!newvars %in% names(ex)]){
e<-get_acs(geography="tract",variables=c(i),state=state,year=year,geometry=F,survey=survey)
e<-spread(data=e[,c("GEOID","variable","estimate")],key=variable,value=estimate,fill=NA)
if(max(na.omit(e[,i]))==1&min(na.omit(e[,i]))==0){#rate and percent values are hard to interpret, but rely on direct imputation
type<-"binary"#binary in final form
}
if(i %in% c("B01001_001","B25001_001","B26001_001")){#count metrics tend to be skewed and should be split evenly to bg
type<-"count"#count only, to be split from tract to bg
}else{#use for central tendency values where direct imputation is required
type<-"rate"#vary from 1 to 100 in final form
}
e<-geo_impute(x=e,geoid="GEOID",from="tract",to="bg",year=year,type=type)
e<-e[,!names(e) %in% c("geometry","geometry.x","geometry.y")]
ex<-merge(ex,e,by.x="GEOID",by.y="bg",all.x=T)
ex<-ex[,!names(ex) %in% c("geometry")]
}
ex<-ex[,c("GEOID",newvars)]
}
base<-ex
#base<-base[,!names(base) %in% c("geometry")]
vars<-data.frame(
variable=c(
"receiptofssiorsnap",
"receiptofssiorsnapinfamilies",
"receiptofsnap",
"householdcashassistfoodorsnap",
"householdsnaponly",
"snapfamilyany",
"snapfamilysnap5p",
"householdreceiptoffoodstamps",
"householdw60psnap",
"householdw18msnap",
"householdmarriedsnap",
"householdmalehomesnap",
"householdfemalehomesnap",
#        "medianincomeofsnapbeneficiaries",
"householdw1pdisabledsnap",
"novehiclesavailable",
#"lowaccesspopsharehalf",
"lowaccesspopshare1","lowaccesspopshare10",
#"lowaccesschildrensharehalf",
"lowaccesschildrenshare1","lowaccesschildrenshare10",
#"lowaccessseniorssharehalf",
"lowaccessseniorsshare1","lowaccessseniorsshare10",
#"lowaccesssnapsharehalf",
"lowaccesssnapshare1","lowaccesssnapshare10",
"groceryfoodstores","supercentersandfoodclubstores","conveniencestores","snapauthorizedfoodstores",
#"wicauthorizedfoodstores",
"fastfoodrestaurants","fullservicerestaurants",
#"foodbanksper1k",
"foodinsec","vlfoodsec"
),
numerator=c(
"B09010_002","B09010_003","B09010_008","B19058_002","B19058_003","B19123_002","B19123_014+B19123_017+B19123_020","B22001_002","B22001_003","B22002_003","B22007_003","B22007_013","B22007_018",
#"B22008_002",
"B22010_003","B08014_002",
#"lapophalf",
"lapop1","lapop10",
#"lakidshalf",
"lakids1","lakids10",
#"laseniorshalf",
"laseniors1","laseniors10",
#"lasnaphalf",
"lasnap1","lasnap10",
"GROCPTH*B01001_001","SUPERCPTH*B01001_001","CONVSPTH*B01001_001","SNAPSPTH*B01001_001",
#"WICSPTH*B01001_001",
"FFRPTH*B01001_001","FSRPTH*B01001_001",
#"FOODBANKS",
"FOODINSEC","VLFOODSEC"
),
denominator=c(
"B09010_001","B09010_001","B09010_001","B19058_001","B19058_001","B19123_001","B19123_013+B19123_016+B19123_019","B22001_001","B22001_002","B22001_002","B22007_002","B22007_002","B22007_002",
#"",
"B22010_002","B08014_001",
#"POP2010",
"POP2010","POP2010",
#"lapophalf",
"lapop1","lapop10",
#"lapophalf",
"lapop1","lapop10",
#"lapophalf",
"lapop1","lapop10",
rep(NA,6),
#"B01001_001",
rep(NA,2)
)
)
lvars<-as.character(na.omit(unlist(str_split(unique(c(vars$numerator,vars$denominator)),"[+/*/]"))))
lvars<-unique(lvars)
ex<-get_acs(geography=geography,variables=lvars[!is.na(as.numeric(substr(lvars,2,5)))],state=state,year=year,geometry=F,survey="acs5")
ex<-ex[!is.na(ex$estimate),]
ex<-as.data.frame(spread(data=ex[,c("GEOID","variable","estimate")],key=variable,value=estimate,fill=NA))
ex[ex==-666666666]<-NA
#remove geographies that are invalid
ex2<-get_acs(geography=geography,variables=c("B01001_001","B25001_001","B26001_001","B19113_001"),state=state,year=year,geometry=F,survey="acs5")#has population and housing units
ex2<-tidyr::spread(ex2[,c("GEOID","variable","estimate")],key=variable,value=estimate,fill=0)
ex2$valid<-ifelse(ex2$B01001_001>100&!is.na(ex2$B01001_001)&#has population >100 per ADI and IMD methods at BG
ex2$B25001_001>30&!is.na(ex2$B25001_001)&
ex2$B26001_001/ex2$B01001_001<0.333&!is.na(ex2$B26001_001),1,0)#and has housing >30 per ADI and IMD methods at BG
ex<-merge(ex,ex2[,c("GEOID",names(ex2)[!names(ex2) %in% names(ex)])],by="GEOID",all.x=T)
ex<-ex[ex$valid==1,]#compute housing on only the valid geographies and removes values for invalid
remove(ex2)
gc()
if(geography=="zip code tabulation area"){
geography<-"zcta"
}
ex2<-prepFood(year=year,geography=geography)#extracted share is incorrect and needs replacement using POP2010 est
ex2<-merge(ex2,ex[,c("GEOID","valid")],by.x="GEOID",by.y="GEOID",all.y=T)
#    ex2[is.na(ex2)]<-0
ex<-merge(ex,ex2[,names(ex2)[!names(ex2) %in% c("valid")]],by.x="GEOID",by.y="GEOID",all.x=T)
ex<-ex[,c(names(ex)[!names(ex) %in% "valid"],"valid")]#make valid last in list
#    lvars<-c(lvars,names(ex2)[!names(ex2) %in% c("geoid")])
lvars<-lvars[lvars %in% names(ex)]
ex<-ex[,c("GEOID",lvars,"B25001_001","B26001_001","B19113_001","valid")]
if(impute==T){
newvars<-unique(c(lvars,"B01001_001","B25001_001","B26001_001","B19113_001"))
if(geography=="block group"){
for(i in newvars[!newvars %in% names(ex)]){
e<-get_acs(geography="tract",variables=c(i),state=state,year=year,geometry=F,survey=survey)
e<-spread(data=e[,c("GEOID","variable","estimate")],key=variable,value=estimate,fill=NA)
if(max(na.omit(e[,i]))==1&min(na.omit(e[,i]))==0){#rate and percent values are hard to interpret, but rely on direct imputation
type<-"binary"#binary in final form
}
if(i %in% c("B01001_001","B25001_001","B26001_001")){#count metrics tend to be skewed and should be split evenly to bg
type<-"count"#count only, to be split from tract to bg
}else{#use for central tendency values where direct imputation is required
type<-"rate"#vary from 1 to 100 in final form
}
e<-geo_impute(x=e,geoid="GEOID",from="tract",to="bg",year=year,type=type)
ex<-merge(ex,e,by.x="GEOID",by.y="bg",all.x=T)
}
ex<-ex[,c("GEOID",newvars,"valid")]
}
if(impute.method=="mice"){
hold<-state
remove(state)
gc()
library(mice)
ex2<-ex[,colnames(ex)[2:(ncol(ex)-1)]]
imp<-mice::mice(ex2,maxit=2,m=5,seed=1,method="cart")#does not run if there is anything in the environment called "state"
ex2<-mice::complete(imp,action="long")
ex2<-ex2[,2:ncol(ex2)]%>%
group_by(.id)%>%
summarise_each(funs=c("mean"))
ex2<-as.data.frame(ex2)
#remove(ex2)
gc()
#imputing one value from ten iterations using a cart to handle univariate values
state<-hold
remove(hold)
gc()
ex$rowid<-rownames(ex)
#impute<-NULL
#for(i in names(imp[["imp"]])){
#  if(length(imp[["imp"]][[i]][[1]])>0){
#    impute<-c(impute,i)
#  }
#}
impute<-NULL
for(i in names(ex)){
if(length(summary(as.factor(is.na(ex[,i]))))>1){
impute<-c(impute,i)
}
}
for(i in impute){
#e<-data.frame(rowid=rownames(imp[["imp"]][[i]]),X1=imp[["imp"]][[i]][,1])
e<-ex2[,c(".id",i)]
names(e)<-c("rowid","X1")
ex<-merge(ex,e,by="rowid",all.x=T)
ex[,i]<-ifelse(is.na(ex[,i])&ex[,"valid"]==1,
ifelse(is.na(ex$X1),mean(na.omit(ex$X1)),ex$X1),#impute mice or mean if mice is still an NA value
ex[,i])
ex<-ex[,!names(ex) %in% c("X1")]
}
ex<-ex[,!names(ex) %in% c("rowid","valid")]
}else{
miss<-NULL
imputed<-NULL
for(i in colnames(ex)[2:(ncol(ex)-1)]){#model imputation of raw attributes
if(impute.method=="rpart"){
f<-paste0(i,"~",paste(c(newvars[!newvars %in% i]),collapse="+"))#at minimum, will predict using pop,housing and group housing stats
#e<-ex[,c("GEOID",c(newvars[!newvars %in% i]))]
e<-ex[,c("GEOID",newvars)]
for(j in names(e)){#mean imputation on our training data
e[,j]<-ifelse(is.na(e[,j]),mean(na.omit(e[,j])),e[,j])#impute mean for each individual attribute missing values in e
}
m<-rpart::rpart(formula=f,data=e,method="anova")#use partition to return values of each attribute using e to fit
expected<-predict(m,newdata=ex)#store expected values from raw data
print(paste0(i," model variance explained ",
round(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)),3)))
#e[,i]<-ifelse(ex$valid==0,NA,#if not valid, return NA
#               ifelse(is.na(e[,i]),expected,e[,i]))#if variable is na return imputed value
if(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2))<0.2&
!is.na(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)))){#r2 is na if expected observed is one value only (all)
miss<-c(miss,i)
}
imputed<-cbind(imputed,expected)
}
if(impute.method=="lm"){
f<-paste0(i,"~",paste(c(newvars[!newvars %in% i]),collapse="+"))#at minimum, will predict using pop,housing and group housing stats
#e<-ex[,c("GEOID",c(newvars[!newvars %in% i]))]
e<-ex[,c("GEOID",newvars)]
for(j in names(e)){#mean imputation on our training data
e[,j]<-ifelse(is.na(e[,j]),mean(na.omit(e[,j])),e[,j])#impute mean for each individual attribute missing values in e
}
m<-lm(e,formula=f)
expected<-predict(m,newdata=e)#store expected values from mean-imputed data
print(paste0(i," model variance explained ",
round(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)),3)))
if(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2))<0.2&
!is.na(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)))){#r2 is na if expected observed is one value only (all)
miss<-c(miss,i)
}
imputed<-cbind(imputed,expected)
}
}
colnames(imputed)<-colnames(ex)[2:(ncol(ex)-1)]
for(i in colnames(ex)[2:(ncol(ex)-1)]){
if(!i %in% c(miss,"B01001_001","B25001_001","B26001_001","B19113_001")){#skip any attributes where r2 is very poor (<.2) or one of my starting predictors
gmin<-min(na.omit(ex[,i]))
gmax<-max(na.omit(ex[,i]))
ex[,i]<-ifelse(is.na(ex[,i]),
imputed[,i],
#e[,i],
ex[,i])
ex[,i]<-ifelse(ex[,i]<gmin,gmin,ifelse(ex[,i]>gmax,gmax,ex[,i]))
}
}
ex<-ex[,c("GEOID",lvars)]
}
}
for(i in vars$variable){
#print(i)
num<-0#operations all have to be the same across elements for these features in num or den
if(stringr::str_count(vars[vars$variable==i,]$numerator,"[+]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$numerator,"[+]")+1)){
#id<-vars[vars$variable==i,]$variable
id<-stringr::str_split(vars[vars$variable==i,]$numerator,"[+]")[[1]][j]
num<-num+as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$numerator,"[/]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$numerator,"[/]")+1)){
#id<-vars[vars$variable==i,]$variable
num<-1#must reassign num if product is expected
id<-stringr::str_split(vars[vars$variable==i,]$numerator,"[/]")[[1]][j]
num<-num/as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$numerator,"[*]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$numerator,"[*]")+1)){
#id<-vars[vars$variable==i,]$variable
id<-stringr::str_split(vars[vars$variable==i,]$numerator,"[*]")[[1]][j]
if(j==1){num<-1}#must reassign num if product is expected
num<-num*as.numeric(ex[,id])
}
}else{
num<-as.numeric(ex[,vars[vars$variable==i,]$numerator])
}
}
}
den<-0
if(!is.na(vars[vars$variable==i,]$denominator)){
if(stringr::str_count(vars[vars$variable==i,]$denominator,"[+]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$denominator,"[+]")+1)){
#id<-vars[vars$variable==i,]$variable
id<-stringr::str_split(vars[vars$variable==i,]$denominator,"[+]")[[1]][j]
den<-den+as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$denominator,"[/]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$denominator,"[/]")+1)){
#id<-vars[vars$variable==i,]$variable
den<-1#must reassign num if product is expected
id<-stringr::str_split(vars[vars$variable==i,]$denominator,"[/]")[[1]][j]
den<-den/as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$denominator,"[*]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$denominator,"[*]")+1)){
#id<-vars[vars$variable==i,]$variable
if(j==1){num<-1}#must reassign num if product is expected
id<-stringr::str_split(vars[vars$variable==i,]$denominator,"[*]")[[1]][j]
den<-den*as.numeric(ex[,id])
}
}else{
den<-as.numeric(ex[,vars[vars$variable==i,]$denominator])
den[is.na(den)]<-0
}
}
}
}
if(length(den)==1){#THIS LINE WAS EDITED TO CORRECT MISMATCH EVALUATION 2-4-25
ex[,i]<-num
}else{
ex[,i]<-ifelse(den==0,0,num/den)#edited to correct div by 0 error
}
}
#clean
ex<-ex[,c("GEOID",vars$variable)]
ex[ex=="Inf"]<-NA
#ex$lowaccesspopsharehalf<-ex$lowaccesspopsharehalf*100
ex$lowaccesspopshare1<-100*ex$lowaccesspopshare1
ex$lowaccesspopshare10<-100*ex$lowaccesspopshare10
#ex$lowaccesschildrensharehalf<-100*ex$lowaccesschildrensharehalf
ex$lowaccesschildrenshare1<-100*ex$lowaccesschildrenshare1
ex$lowaccesschildrenshare10<-100*ex$lowaccesschildrenshare10
#ex$lowaccessseniorssharehalf<-100*ex$lowaccessseniorssharehalf
ex$lowaccessseniorsshare1<-100*ex$lowaccessseniorsshare1
ex$lowaccessseniorsshare10<-100*ex$lowaccessseniorsshare10
#ex$lowaccesssnapsharehalf<-100*ex$lowaccesssnapsharehalf
ex$lowaccesssnapshare1<-100*ex$lowaccesssnapshare1
ex$lowaccesssnapshare10<-100*ex$lowaccesssnapshare10
ex$groceryfoodstores<-ex$groceryfoodstores/1000
ex$supercentersandfoodclubstores<-ex$supercentersandfoodclubstores/1000
ex$conveniencestores<-ex$conveniencestores/1000
ex$snapauthorizedfoodstores<-ex$snapauthorizedfoodstores/1000
#ex$wicauthorizedfoodstores<-ex$wicauthorizedfoodstores/1000
ex$fastfoodrestaurants<-ex$fastfoodrestaurants/1000
ex$fullservicerestaurants<-ex$fullservicerestaurants/1000
#ex$foodbanksper1k<-ex$foodbanksper1k*1000
ex$receiptofssiorsnap<-100*ex$receiptofssiorsnap
ex$receiptofssiorsnapinfamilies<-100*ex$receiptofssiorsnapinfamilies
ex$receiptofsnap<-100*ex$receiptofsnap
ex$householdcashassistfoodorsnap<-100*ex$householdcashassistfoodorsnap
ex$householdsnaponly<-100*ex$householdsnaponly
ex$snapfamilyany<-100*ex$snapfamilyany
ex$snapfamilysnap5p<-100*ex$snapfamilysnap5p
ex$householdreceiptoffoodstamps<-100*ex$householdreceiptoffoodstamps
ex$householdw60psnap<-100*ex$householdw60psnap
ex$householdw18msnap<-100*ex$householdw18msnap
ex$householdmarriedsnap<-100*ex$householdmarriedsnap
ex$householdmalehomesnap<-100*ex$householdmalehomesnap
ex$householdfemalehomesnap<-100*ex$householdfemalehomesnap
ex$householdw1pdisabledsnap<-100*ex$householdw1pdisabledsnap
ex$novehiclesavailable<-100*ex$novehiclesavailable
ex$NAME<-as.character(1:nrow(ex))
ex<-ex[,c("GEOID","NAME",names(ex)[!names(ex) %in% c("GEOID","NAME","valid")&is.na(as.numeric(substr(names(ex),2,5)))&str_detect(names(ex),"half")==F])]
out<-makeIndex(x=ex[complete.cases(ex),],geoid="GEOID",nfactors=4,state=NULL)
out$corr.mat
out$scree
out$fa_result
out$factor_members
table(quantile(ex$groceryfoodstores,c(.2,.2,.2,.2,.2)))
table(quantile(na.omit(ex$groceryfoodstores),c(.2,.2,.2,.2,.2)))
table(quantile(na.omit(ex$groceryfoodstores),levels=c(.2,.2,.2,.2,.2)))
plot(ex$groceryfoodstores,ex$conveniencestores)
plot(ex$groceryfoodstores,ex$fastfoodrestaurants)
hist(ex$groceryfoodstores)
hist(ex$groceryfoodstores,breaks=2-)
hist(ex$groceryfoodstores,breaks=20)
hist(ex$groceryfoodstores,breaks=200)
summary(ex$groceryfoodstores)
summary(ex$foodinsec)
impute
summary(ex$foodinsec)
summary(ex$vlfoodinsec)
summary(ex$vlfoodsec)
out$pca_result
out$fa_result
out$factor_members
