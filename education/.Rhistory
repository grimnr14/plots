#e<-data.frame(rowid=rownames(imp[["imp"]][[i]]),X1=imp[["imp"]][[i]][,1])
e<-ex2[,c(".id",i)]
names(e)<-c("rowid","X1")
ex<-merge(ex,e,by="rowid",all.x=T)
ex[,i]<-ifelse(is.na(ex[,i])&ex[,"valid"]==1,
ifelse(is.na(ex$X1),mean(na.omit(ex$X1)),ex$X1),#impute mice or mean if mice is still an NA value
ex[,i])
ex<-ex[,!names(ex) %in% c("X1")]
}
ex<-ex[,!names(ex) %in% c("rowid","valid")]
}else{
miss<-NULL
imputed<-NULL
for(i in colnames(ex)[2:(ncol(ex)-1)]){#model imputation of raw attributes
if(impute.method=="rpart"){
f<-paste0(i,"~",paste(c(newvars[!newvars %in% i]),collapse="+"))#at minimum, will predict using pop,housing and group housing stats
#e<-ex[,c("GEOID",c(newvars[!newvars %in% i]))]
e<-ex[,c("GEOID",newvars)]
for(j in names(e)){#mean imputation on our training data
e[,j]<-ifelse(is.na(e[,j]),mean(na.omit(e[,j])),e[,j])#impute mean for each individual attribute missing values in e
}
m<-rpart::rpart(formula=f,data=e,method="anova")#use partition to return values of each attribute using e to fit
expected<-predict(m,newdata=ex)#store expected values from raw data
print(paste0(i," model variance explained ",
round(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)),3)))
#e[,i]<-ifelse(ex$valid==0,NA,#if not valid, return NA
#               ifelse(is.na(e[,i]),expected,e[,i]))#if variable is na return imputed value
if(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2))<0.2&
!is.na(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)))){#r2 is na if expected observed is one value only (all)
miss<-c(miss,i)
}
imputed<-cbind(imputed,expected)
}
if(impute.method=="lm"){
f<-paste0(i,"~",paste(c(newvars[!newvars %in% i]),collapse="+"))#at minimum, will predict using pop,housing and group housing stats
#e<-ex[,c("GEOID",c(newvars[!newvars %in% i]))]
e<-ex[,c("GEOID",newvars)]
for(j in names(e)){#mean imputation on our training data
e[,j]<-ifelse(is.na(e[,j]),mean(na.omit(e[,j])),e[,j])#impute mean for each individual attribute missing values in e
}
m<-lm(e,formula=f)
expected<-predict(m,newdata=e)#store expected values from mean-imputed data
print(paste0(i," model variance explained ",
round(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)),3)))
if(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2))<0.2&
!is.na(1-(sum((expected[!is.na(ex[,i])]-ex[!is.na(ex[,i]),i])^2)/sum(ex[!is.na(ex[,i]),i]^2)))){#r2 is na if expected observed is one value only (all)
miss<-c(miss,i)
}
imputed<-cbind(imputed,expected)
}
}
colnames(imputed)<-colnames(ex)[2:(ncol(ex)-1)]
for(i in colnames(ex)[2:(ncol(ex)-1)]){
if(!i %in% c(miss,"B01001_001","B25001_001","B26001_001","B19113_001")){#skip any attributes where r2 is very poor (<.2) or one of my starting predictors
gmin<-min(na.omit(ex[,i]))
gmax<-max(na.omit(ex[,i]))
ex[,i]<-ifelse(is.na(ex[,i]),
imputed[,i],
#e[,i],
ex[,i])
ex[,i]<-ifelse(ex[,i]<gmin,gmin,ifelse(ex[,i]>gmax,gmax,ex[,i]))
}
}
ex<-ex[,c("GEOID",lvars)]
}
}
for(i in vars$variable){
#print(i)
num<-0#operations all have to be the same across elements for these features in num or den
if(stringr::str_count(vars[vars$variable==i,]$numerator,"[+]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$numerator,"[+]")+1)){
#id<-vars[vars$variable==i,]$variable
id<-stringr::str_split(vars[vars$variable==i,]$numerator,"[+]")[[1]][j]
num<-num+as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$numerator,"[/]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$numerator,"[/]")+1)){
#id<-vars[vars$variable==i,]$variable
num<-1#must reassign num if product is expected
id<-stringr::str_split(vars[vars$variable==i,]$numerator,"[/]")[[1]][j]
num<-num/as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$numerator,"[*]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$numerator,"[*]")+1)){
#id<-vars[vars$variable==i,]$variable
id<-stringr::str_split(vars[vars$variable==i,]$numerator,"[*]")[[1]][j]
if(j==1){num<-1}#must reassign num if product is expected
num<-num*as.numeric(ex[,id])
}
}else{
num<-as.numeric(ex[,vars[vars$variable==i,]$numerator])
}
}
}
den<-0
if(!is.na(vars[vars$variable==i,]$denominator)){
if(stringr::str_count(vars[vars$variable==i,]$denominator,"[+]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$denominator,"[+]")+1)){
#id<-vars[vars$variable==i,]$variable
id<-stringr::str_split(vars[vars$variable==i,]$denominator,"[+]")[[1]][j]
den<-den+as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$denominator,"[/]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$denominator,"[/]")+1)){
#id<-vars[vars$variable==i,]$variable
den<-1#must reassign num if product is expected
id<-stringr::str_split(vars[vars$variable==i,]$denominator,"[/]")[[1]][j]
den<-den/as.numeric(ex[,id])
}
}else{
if(stringr::str_count(vars[vars$variable==i,]$denominator,"[*]")>0){
for(j in 1:(stringr::str_count(vars[vars$variable==i,]$denominator,"[*]")+1)){
#id<-vars[vars$variable==i,]$variable
if(j==1){num<-1}#must reassign num if product is expected
id<-stringr::str_split(vars[vars$variable==i,]$denominator,"[*]")[[1]][j]
den<-den*as.numeric(ex[,id])
}
}else{
den<-as.numeric(ex[,vars[vars$variable==i,]$denominator])
den[is.na(den)]<-0
}
}
}
}
if(length(den)==1){#THIS LINE WAS EDITED TO CORRECT MISMATCH EVALUATION 2-4-25
ex[,i]<-num
}else{
ex[,i]<-ifelse(den==0,0,num/den)#edited to correct div by 0 error
}
}
#clean
ex<-ex[,c("GEOID",vars$variable)]
ex[ex=="Inf"]<-NA
#    ex$ratioEnrolledPrivateToPublic<-ifelse(ex$pctChildrenEnrolledSchoolPrivate/ex$pctChildrenEnrolledSchoolPublic=="Inf",999,ex$pctChildrenEnrolledSchoolPrivate/ex$pctChildrenEnrolledSchoolPublic)
ex<-ex[,!names(ex) %in% c("pctChildrenEnrolledSchoolPrivate","pctChildrenEnrolledSchoolPublic")]
ex$pctWomenLTHS<-100*ex$pctWomenLTHS
#ex$pctWomenLTHSbirth<-100*ex$pctWomenLTHSbirth
ex$pctEnrolledSchool<-100*ex$pctEnrolledSchool
#    ex$pctEnrolledSchoolInK12<-100*ex$pctEnrolledSchoolInK12
#    ex$pctEnrolledSchoolInHigherEd<-100*ex$pctEnrolledSchoolInHigherEd
#    ex$pctChildrenNotEnrolledSchool<-100*ex$pctChildrenNotEnrolledSchool
#    ex$pctChildrenEnrolledSchoolPublic<-100*ex$pctChildrenEnrolledInK12Public
#    ex$pctChildrenEnrolledSchoolPrivate<-100*ex$pctChildrenEnrolledInK12Private
#    ex$pctChildrenEnrolledInK12Public<-100*ex$pctChildrenEnrolledInK12Public
#    ex$pctChildrenEnrolledInK12Private<-100*ex$pctChildrenEnrolledInK12Private
#    ex$priEduUtilization<-ifelse(is.na(ex$pctChildrenEnrolledInK12Private)|is.na(ex$pctChildrenEnrolledInK12Public),0,ex$pctChildrenEnrolledInK12Private/ex$pctChildrenEnrolledInK12Public)
#    ex$pctChildrenLTE5InPreK<-100*ex$pctChildrenLTE5InPreK
ex$pctAdultsInHigherEd<-100*ex$pctAdultsInHigherEd
#    ex$pctAdultsInHigherEdPublic<-100*ex$pctAdultsInHigherEdPublic
#    ex$pctAdultsInHigherEdPrivate<-100*ex$pctAdultsInHigherEdPrivate
#    ex$pctChildrenWithDisability<-100*ex$pctChildrenWithDisability
ex$pctAdults4yrDegree<-100*ex$pctAdults4yrDegree
#    ex$pctAdultsGraduateDegree<-100*ex$pctAdultsGraduateDegree
ex$pctpeoplewithlessthan9thgrade<-100*ex$pctpeoplewithlessthan9thgrade
ex$pctpeoplewithatleasthseducation<-100*ex$pctpeoplewithatleasthseducation
#    ex$pctAdults4yrDegreeInPoverty<-100*ex$pctAdults4yrDegreeInPoverty
ex$medIncomeAdults4yrDegree<-ex$medIncomeAdults4yrDegree/1000
#    ex$medIncomeAdultsHSDiploma<-ex$medIncomeAdultsHSDiploma/1000
ex$medEducatorIncome<-ex$medEducatorIncome/1000
#    ex$pctEducatorAge2539<-100*ex$pctEducatorAge2539
#    ex$pctEducatorAge4064<-100*ex$pctEducatorAge4064
#    ex$pctEducatorAge65p<-100*ex$pctEducatorAge65p
ex$pctProfessionalsInEducation<-100*ex$pctProfessionalsInEducation
#    ex$pubSchoolsPer1000K<-1000*ex$pubSchoolsPer1000K
#    ex$pubPriSchoolsPer1000k<-1000*ex$pubPriSchoolsPer1000k
ex$preKProgramPerChild<-1000*ex$preKProgramPerChild
#ex$studentsEnrolledPubPriK12<-ex$studentsEnrolledPubPriK12/1000
#ex$estStudentsPerFTETeacher<-ifelse(ex$estStudentsPerFTETeacher==0,NA,ex$estStudentsPerFTETeacher)#this doesnt have enough data
#ex$priEduUtilization<-100*ifelse(ex$priEduUtilization==1,NA,ex$priEduUtilization)#this one does not make sense and too missing
#ex$schoolFreeLunch<-100*ex$schoolFreeLunch
ex$totalPrimarySecondaryVocationalSchools<-ifelse(is.na(ex$totalPrimarySecondaryVocationalSchools),0,ex$totalPrimarySecondaryVocationalSchools)#do not impute expected values on schools
#    ex$totalPostSecondary<-ifelse(is.na(ex$totalPostSecondary),0,ex$totalPostSecondary)
#    ex$totalDegreeGranting<-ifelse(is.na(ex$totalDegreeGranting),0,ex$totalDegreeGranting)
#    ex$totalPublicUni<-ifelse(is.na(ex$totalPublicUni),0,ex$totalPublicUni)
#    ex$undergradInstPer1000K<-ifelse(is.na(ex$undergradInstPer1000K),0,1000*ex$undergradInstPer1000K)
#    ex$gradInstPer1000K<-ifelse(is.na(ex$gradInstPer1000K),0,1000*ex$gradInstPer1000K)
#    outs<-NULL
#    for(u in unique(substr(ex$GEOID,1,2))){
#      out<-ex[substr(ex$GEOID,1,2)==u,c("GEOID","avgInStateUndergradTuition")]#,"avgInStateGradTuition","avgAnnualCostRoomBoard")]
#      out$avgInStateUndergradTuition<-ifelse(is.na(out$avgInStateUndergradTuition)&substr(out$GEOID,1,2)==u,
#                                            median(na.omit(out[substr(out$GEOID,1,2)==u,]$avgInStateUndergradTuition)),
#                                            out$avgInStateUndergradTuition)/1000
#      outs<-rbind(outs,out)
#    }
#    ex<-merge(ex[,!names(ex) %in% c("avgInStateUndergradTuition")],outs,by="GEOID",all.x=T)#,"avgInStateUndergradTuition","avgAnnualCostRoomBoard")],outs,by="GEOID",all.x=T)
#    remove(outs,out)
#    gc()
#ex$totalUniInstructionalStaff<-ifelse(is.na(ex$totalUniInstructionalStaff),0,ex$totalUniInstructionalStaff)
#ex$estInstructionalStaffSalary<-ifelse(is.na(ex$estInstructionalStaffSalary),median(na.omit(ex$estInstructionalStaffSalary)),ex$estInstructionalStaffSalary)/1000#too leptokeurtic
vars<-c("pctWomenLTHS","pctpeoplewithlessthan9thgrade","pctpeoplewithatleasthseducation","pctAdults4yrDegree","medIncomeAdults4yrDegree","medEducatorIncome","pctProfessionalsInEducation","pctEnrolledSchool","pctAdultsInHigherEd","totalPrimarySecondaryVocationalSchools","preKProgramPerChild")
ex$NAME<-as.character(1:nrow(ex))
ex<-ex[,c("GEOID","NAME",names(ex)[!names(ex) %in% c("GEOID","NAME","valid")&is.na(as.numeric(substr(names(ex),2,5)))&str_detect(names(ex),"half")==F])]
out<-makeIndex(x=ex[complete.cases(ex),],geoid="GEOID",nfactors=4,state=NULL,
set.factor=list(attainment=c("pctWomenLTHS","pctpeoplewithlessthan9thgrade","pctpeoplewithatleasthseducation","pctAdults4yrDegree"),
quality=c("medIncomeAdults4yrDegree","medEducatorIncome","pctProfessionalsInEducation"),
enrollment=c("pctEnrolledSchool","pctAdultsInHigherEd"),
access=c("totalPrimarySecondaryVocationalSchools","preKProgramPerChild"))
)
#    out<-makeIndex(x=ex[complete.cases(ex),],geoid="GEOID",nfactors=4,state=NULL,
#                   set.factor=list(financial=c(),
#                                   ownership=c(),
#                                   building_quality=c(),
#                                   crowding=c()
#                   ))
education<-merge(ex[,c("GEOID",vars)],
out$score[,c("GEOID","full_score","ranked_percentile")],
by="GEOID",all.x=T)
education<-merge(education,
out$sub_score[,c("GEOID","factor_1","factor_2","factor_3","factor_4")],
by="GEOID",all.x=T)
#education$full_score<-education$full_score-100#reverse direction
#education$full_score<--education$full_score
#education$full_score<-education$full_score+100
#education$ranked_percentile<-100-education$ranked_percentile
education<-score_state(x=education,geography=geography,geoid="GEOID",year=year)
education<-education[,!names(education) %in% c("STATEFP","state_ranked_decile")]
names(education)<-c("GEOID",vars,"education_score","education_rnk",
"attainment_score","quality_education_score","enrollment_score","education_access_score",
#"geometry",#toggle off from zcta...
"education_state_rnk")
if(calc.adi==T){
education<-education[,!names(education) %in% c("pctpeoplewithlessthan9thgrade","pctpeoplewithatleasthseducation")]
}
base<-merge(base,education,by="GEOID",all.x=T)
gc()
}
base<-merge(base,map[,!names(map) %in% c("geometry")],by="GEOID",all.x=T)
base[!duplicated(base),]
}
testing<-F
if(testing==T){
source("https://raw.githubusercontent.com/grimnr14/R-functions/refs/heads/main/flatMap.R")
ex<-pullACS(geography="county",variables=c("B01001_001","B01002_001"),state=state.abb,geometry=F,year=2023,calc.adi=F,survey="acs5",calc="transportation")
ex<-pullACS(geography="county",variables=c("B01001_001","B01002_001"),state=state.abb,geometry=F,year=2019,calc.adi=F,survey="acs5",calc="food")
ex<-pullACS(geography="county",variables=c("B01001_001","B01002_001"),state="MD",impute=T,impute.method="rpart",geometry=F,year=2023,calc.adi=F,survey="acs5",calc="transportation")
ex<-pullACS(geography="tract",variables=c("B01001_001","B01002_001"),state=state.abb,geometry=F,year=2022,calc.adi=F,survey="acs5",calc="transportation")
ex<-pullACS(geography="zcta",variables=c("B01001_001","B01002_001"),state=NULL,geometry=F,year=2020,calc.adi=F,survey="acs5",calc="housing")
flat_map(data=as.data.frame(ex),
year=2023,state="MD",geography="county",
geoid="GEOID",var="ranked_percentile")
exs<-NULL
for(j in c("county","zip code tabulation area","tract")){
saveRDS(pullACS(geography=j,state=state.abb,geometry=T,year=2019,calc="housing",calc.adi=F,survey="acs5"),
paste0("C:/Users/chris/OneDrive/Desktop/GeoHealth/data/housing_",j,"_2019_sf.rds"))
ex<-pullACS(geography=j,state=state.abb,year=2019,calc="housing",calc.adi=F,geometry=F,survey="acs5")
ex<-pullACS(geography=j,state=state.abb,year=2019,calc="housing",calc.adi=F,geometry=F,survey="acs5",impute=T)
nams<-names(ex)[!names(ex) %in% c("B01001_001","GEOID","housing_score","housing_rnk","financial_score","ownership_score","building_quality_score","other_housing_score")]
for(i in nams){
nam<-paste0("z_",i)
#ex[,nam]<- liver::transform(ex[,i], method = "zscore") #x is now normalized THIS STOPPED WORKING
ex[,nam]<-liver::zscore(ex[,i])
}
ex$NAME<-as.character(1:nrow(ex))
ex$geography<-j
exs<-rbind(exs,ex)
obj<-makeIndex(x=ex[,names(ex) %in% c("GEOID","NAME",nams)],geoid="GEOID",nfactors=4,state=NULL,
set.factor=list(financial=c("housingvalue","mortgage","mortgagecost","mortgagetax","mortgageval","rentgross"),
ownership=c("occupyown","unitsownpop","vehicle","rooms"),
building_quality=c("fuelheat","kitchen","plumbing"),
other=c("occupy","rentprcinc","units"))
)
saveRDS(obj,paste0("C:/Users/chris/OneDrive/Desktop/GeoHealth/data/housing_",j,"_2019_output.rds"))
}
saveRDS(exs[,c("GEOID","geography",nams,paste0("z_",nams),"housing_score","housing_rnk","financial_score","ownership_score","building_quality_score","other_housing_score")],
paste0("C:/Users/chris/OneDrive/Desktop/GeoHealth/data/housing_2019.rds"))
}
if(testing==T){
test1<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=F,calc="housing")
test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="rpart",calc="housing")
test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="rpart",calc="transportation")
test2<-pullACS(geography="county",state=state.abb,geometry=F,year=2019,impute=T,impute.method="rpart",calc="education")
#test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="lm",calc="housing")
#test2<-pullACS(geography="zip code tabulation area",state=state.abb,geometry=F,year=2019,impute=T,impute.method="mice",calc="housing")#mice broken inside of pullACS function
source("C:/Users/chris/OneDrive/Desktop/GeoHealth/scripts/jaccard.r")
jaccard(round(test1[,2:(ncol(test1)-1)],1),round(test2[rownames(test1),2:(ncol(test2)-1)],1))
summary(test1)
summary(test2)
summary(test1[,2:(ncol(test1)-1)]-test2[rownames(test1),2:(ncol(test2)-1)])
}
#years<-2010:2023
#geos<-c("county","zcta","tract")
#outs<-NULL
#for(y in years){
#  for(g in geos){
#    if(g=="zcta"&y<2020){
#      g<-"zip code tabulation area"
#      o<-pullACS(geography=g,state=NULL,geometry=F,year=y,impute=F,calc="none")
#      o$geolevel<-"zcta"
#      o$year<-y
#    }
#    if(g=="zcta"&y>=2020){
#      o<-pullACS(geography=g,state=NULL,geometry=F,year=y,impute=F,calc="none")
#      o$geolevel<-"zcta"
#      o$year<-y
#    }
#    if(g!="zcta"){
#      o<-pullACS(geography=g,year=y,state=state.abb,geometry=F,impute=F,calc="none")
#      o$geolevel<-g
#      o$year<-y
#    }
#    outs<-rbind(outs,o)
#    print(g)
#  }
#  print(y)
#}
#write.table(outs,"C:/Users/chris/OneDrive/Desktop/GeoHealth/data/population.csv",sep=",",col.names=T,row.names=F)
#creating annual education index files
#C Kitchen
#9-23-25
#set directories----
input<-"C:/Users/chris/OneDrive/Desktop/GeoHealth/scripts/"
output<-"C:/Users/chris/OneDrive/Desktop/GeoHealth/data/"
#read functions----
source(paste0(input,"pullACS/pullACS.R"))#contains CK api key
#pull non-imputed by year-geo----
inc<-c(unique(fips_codes$state_code[fips_codes$state %in% state.abb]),"11")
for(i in c(
2023:2016
)){
if(i<=2019){
geos<-c("county",
"zip code tabulation area",
"tract")#no non-imputed block groups
for(j in geos){
out<-pullACS(geography=j,variables=c("B01001_001","B25001_001","B26001_001"),geometry=F,year=i,state=state.abb,impute=F,calc="education")
if(j %in% c("county","tract","block group")){
out<-out[substr(out$GEOID,1,2) %in% inc,]
}
write.table(out,paste0(output,"education/education_original_pca_",j,"_",i,".csv"),sep=",",col.names=T,row.names=F)
}
}else{
geos<-c("county",
"zcta",
"tract")
for(j in geos){
if(j %in% c("tract")){
out<-pullACS(geography=j,variables=c("B01001_001","B25001_001","B26001_001"),geometry=F,year=i,state=state.abb,impute=F,calc="education")
if(j %in% c("county","tract","block group")){
out<-out[substr(out$GEOID,1,2) %in% inc,]
}
write.table(out,paste0(output,"education/education_original_pca_",j,"_",i,".csv"),sep=",",col.names=T,row.names=F)
}else{
out<-pullACS(geography=j,variables=c("B01001_001","B25001_001","B26001_001"),geometry=F,year=i,state=NULL,impute=F,calc="education")
if(j %in% c("county","tract","block group")){
out<-out[substr(out$GEOID,1,2) %in% inc,]
}
write.table(out,paste0(output,"education/education_original_pca_",j,"_",i,".csv"),sep=",",col.names=T,row.names=F)
}
}
}
}
#pull cart-imputed by year-geo----
for(k in c(
"rpart"#,
#"lm",
#"mice"
)){
for(i in c(2023:2016)){
if(i<=2019){
geos<-c("county"
,"zip code tabulation area"
,"tract"
#,"block group"
)#bg require imputed values and cannot be original pca
for(j in geos){
out<-pullACS(geography=j,variables=c("B01001_001","B25001_001","B26001_001"),geometry=F,year=i,state=state.abb,impute=T,impute.method=k,calc="education")
if(j %in% c("county","tract","block group")){
out<-out[substr(out$GEOID,1,2) %in% inc,]
}
write.table(out,paste0(output,"education/education_",k,"_imputed_pca_",j,"_",i,".csv"),sep=",",col.names=T,row.names=F)
}
}else{
geos<-c("county"
,"zcta"
,"tract"
#,"block group"
)
for(j in geos){
if(j %in% c("tract","block group")){
out<-pullACS(geography=j,variables=c("B01001_001","B25001_001","B26001_001"),geometry=F,year=i,state=state.abb,impute=T,impute.method=k,calc="education")
if(j %in% c("county","tract","block group")){
out<-out[substr(out$GEOID,1,2) %in% inc,]
}
write.table(out,paste0(output,"education/education_",k,"_imputed_pca_",j,"_",i,".csv"),sep=",",col.names=T,row.names=F)
}else{
out<-pullACS(geography=j,variables=c("B01001_001","B25001_001","B26001_001"),geometry=F,year=i,state=NULL,impute=T,calc="education")
if(j %in% c("county","tract","block group")){
out<-out[substr(out$GEOID,1,2) %in% inc,]
}
write.table(out,paste0(output,"education/education_",k,"_imputed_pca_",j,"_",i,".csv"),sep=",",col.names=T,row.names=F)
}
}
}
}
}
ex<-dir(paste0(output,"education/"))
ex<-ex[str_detect(ex,"rpart_")&str_detect(ex,"block group")==F]
for(i in ex){
imp<-read.csv(paste0(output,"education/",i),header=T)
ori<-read.csv(paste0(output,"education/education_original_pca_",substr(i,str_locate(i,pattern="pca_")[2][[1]]+1,nchar(i))),header=T)
new<-merge(imp,ori,by=c("GEOID","NAME"),all.x=T)
charlim<-ifelse(str_detect(i,"county"),5,
ifelse(str_detect(i,"zcta")|str_detect(i,"zip code tabulation area"),5,
ifelse(str_detect(i,"tract"),11,
ifelse(str_detect(i,"block group"),12,NA))))
new$GEOID<-ifelse(nchar(new$GEOID)!=charlim,str_pad(new$GEOID,width=charlim,side="left",pad="0"),new$GEOID)
new$sumlevel<-ifelse(
nchar(new$GEOID)==5&str_detect(new$NAME,"ZCTA")==F,"050",
ifelse(
nchar(new$GEOID)==5&str_detect(new$NAME,"ZCTA")==T,"860",
ifelse(
nchar(new$GEOID)==11,"140",
ifelse(
nchar(new$GEOID)==12,"150",NA
)
)
)
)
new$source<-"ACS5"
new$year<-substr(i,nchar(i)-7,nchar(i)-4)
new$geolevel<-ifelse(
new$sumlevel=="050","county",
ifelse(new$sumlevel=="860","zcta",
ifelse(new$sumlevel=="140","tract",
ifelse(new$sumlevel=="150","bg",NA)))
)
new$geoname<-new$NAME
new$type<-ifelse(
is.na(new$education_rnk.x)&(new$B01001_001.x<=100|new$B25001_001.x<=30|(new$B26001_001.x/new$B01001_001.x)<=0.333),"suppressed",
ifelse(
is.na(new$education_rnk.y)&is.na(new$education_rnk.x),"missing",
ifelse(
!is.na(new$education_rnk.y)&!is.na(new$education_rnk.x),"original",
ifelse(
is.na(new$education_rnk.y)&!is.na(new$education_rnk.x),"imputed",
NA
)
)
)
)
new$geoid<-paste0(new$sumlevel,"00US",new$GEOID)
new$education_score<-round(new$education_score.x,4)
new$education_rnk<-round(new$education_rnk.x,4)
new$education_state_rnk<-round(new$education_state_rnk.x,4)
out<-new[,c("geoid","geoname","geolevel","sumlevel","year","source","type",
#"financial_score","ownership_score","building_quality_score","crowding_score",
"education_score","education_rnk","education_state_rnk")]
write.table(out,paste0(output,"education/combined education index 2016-2023.csv"),sep=",",qmethod="double",row.names=F,col.names=T,append=T)
print(out[1,])
}
out<-read.csv(paste0(output,"education/combined education index 2016-2023.csv"),header=T)
out<-out[out$year %in% c(2019,2023)&out$geolevel %in% c("county","tract","zcta"),
c("geoid",
#"geoname",
"geolevel","year",
#"financial_score","ownership_score","building_quality_score","crowding_score",
"education_score","education_rnk","education_state_rnk")]
write.table(out,paste0(output,"education/brief education index 2019-2023.csv"),sep=",",qmethod="double",row.names=F,col.names=T)
setwd("C:/Users/chris/OneDrive/Desktop/GeoHealth/data/education/plots/")
source("https://raw.githubusercontent.com/grimnr14/R-functions/refs/heads/main/flatMap.R")
library(stringr)
library(zippeR)
for(y in c(2019,2023)){
for(g in c("county",
"zcta",
"tract"
)){
for(l in c("education_rnk","education_state_rnk","education_score")){
if(y==2019&g=="zcta"){
g<-"zip code tabulation area"
if(g=="zcta"|g=="zip code tabulation area"){
state.list<-NULL
}
}else{
state.list<-state.abb
}
d1<-read.csv(paste0("../education_rpart_imputed_pca_",g,"_",y,".csv"),header=T)
d1$GEOID<-ifelse(nchar(d1$GEOID)!=5&g=="county",paste0("0",d1$GEOID),as.character(d1$GEOID))
d1$GEOID<-ifelse(nchar(d1$GEOID)!=5&(g=="zcta"|g=="zip code tabulation area"),str_pad(d1$GEOID,side="left",width=5,pad="0"),as.character(d1$GEOID))
d1$GEOID<-ifelse(nchar(d1$GEOID)!=11&g=="tract",paste0("0",d1$GEOID),as.character(d1$GEOID))
d1<-d1[!is.na(d1$education_rnk),c("GEOID","NAME",l)]
for(s in state.list){
code<-fips_codes[fips_codes$state==s,]
zips<-zippeR::zi_list_zctas(year=y,state=code$state_code[1],method="intersect")
if(g=="county"){
png(paste0("education_",s,"_",g,"_",y,"_",l,".png"),width=1600,height=1600)
print(flat_map(data=d1,#[d1$GEOID %in% paste0(code$state_code,code$county_code),],
year=ifelse(y<2020,2010,2020),
state=s,var=l,geography=ifelse(g=="zcta"|g=="zip code tabulation area","zcta5",g),geoid="GEOID",palette="RdBu",bin=8,type="flat"))
dev.off()
}
if(g=="zcta"|g=="zip code tabulation area"){
png(paste0("education_",s,"_",g,"_",y,"_",l,".png"),width=1600,height=1600)
print(flat_map(data=d1,#[d1$GEOID %in% zips,],
year=ifelse(y<2020,2010,2020),
state=s,var=l,geography=ifelse(g=="zcta"|g=="zip code tabulation area","zcta5",g),geoid="GEOID",palette="RdBu",bin=8,type="flat"))
dev.off()
}
if(g=="tract"){
png(paste0("education_",s,"_",g,"_",y,"_",l,".png"),width=1600,height=1600)
print(flat_map(data=d1,#[substr(d1$GEOID,1,5) %in% paste0(code$state_code,code$county_code),],
year=ifelse(y<2020,2010,2020),
state=s,var=l,geography=ifelse(g=="zcta"|g=="zip code tabulation area","zcta5",g),geoid="GEOID",palette="RdBu",bin=8,type="flat"))
dev.off()
}
}
}
}
}
